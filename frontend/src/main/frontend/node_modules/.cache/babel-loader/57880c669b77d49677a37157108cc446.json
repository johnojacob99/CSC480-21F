{"ast":null,"code":"import b64toBlob from \"b64-to-blob\";\nexport const base64ArrayBuffer = arrayBuffer => {\n  var base64 = \"\";\n  var encodings = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var bytes = new Uint8Array(arrayBuffer);\n  var byteLength = bytes.byteLength;\n  var byteRemainder = byteLength % 3;\n  var mainLength = byteLength - byteRemainder;\n  var a, b, c, d;\n  var chunk; // Main loop deals with bytes in chunks of 3\n\n  for (var i = 0; i < mainLength; i = i + 3) {\n    // Combine the three bytes into a single integer\n    chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2]; // Use bitmasks to extract 6-bit segments from the triplet\n\n    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n\n    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n\n    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n\n    d = chunk & 63; // 63       = 2^6 - 1\n    // Convert the raw binary segments to the appropriate ASCII encoding\n\n    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n  } // Deal with the remaining bytes and padding\n\n\n  if (byteRemainder === 1) {\n    chunk = bytes[mainLength];\n    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n    // Set the 4 least significant bits to zero\n\n    b = (chunk & 3) << 4; // 3   = 2^2 - 1\n\n    base64 += encodings[a] + encodings[b] + \"==\";\n  } else if (byteRemainder === 2) {\n    chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];\n    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n\n    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n    // Set the 2 least significant bits to zero\n\n    c = (chunk & 15) << 2; // 15    = 2^4 - 1\n\n    base64 += encodings[a] + encodings[b] + encodings[c] + \"=\";\n  }\n\n  return base64;\n};\n\nconst openNewTab = response => {\n  var contentType = \"application/pdf\";\n  var sliceSize = 512;\n  var byteCharacters = atob(response);\n  var byteArrays = [];\n\n  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {\n    var slice = byteCharacters.slice(offset, offset + sliceSize);\n    var byteNumbers = new Array(slice.length);\n\n    for (var i = 0; i < slice.length; i++) {\n      byteNumbers[i] = slice.charCodeAt(i);\n    }\n\n    var byteArray = new Uint8Array(byteNumbers);\n    byteArrays.push(byteArray);\n  }\n\n  var blob = new Blob(byteArrays, {\n    type: contentType\n  });\n  blob = b64toBlob(response, contentType);\n  var blobUrl = URL.createObjectURL(blob);\n  return blobUrl;\n};\n\nexport const handleConvertByteArrayToPdf = byteArr => {\n  if (byteArr === \"\") {\n    alert(\"Input must not be empty !\");\n  } else {\n    let data = byteArr.toString().trim().replace(/ /g, \"\");\n    data.replace(/\\r?\\n|\\r/g, \"\");\n    let arrData = JSON.parse(\"[\" + data + \"]\");\n    const base64 = base64ArrayBuffer(arrData);\n    return openNewTab(base64);\n  }\n};","map":{"version":3,"sources":["/home/ductran/Desktop/CSC480-21F/frontend/src/main/frontend/src/utils/byteArrayToPDF.js"],"names":["b64toBlob","base64ArrayBuffer","arrayBuffer","base64","encodings","bytes","Uint8Array","byteLength","byteRemainder","mainLength","a","b","c","d","chunk","i","openNewTab","response","contentType","sliceSize","byteCharacters","atob","byteArrays","offset","length","slice","byteNumbers","Array","charCodeAt","byteArray","push","blob","Blob","type","blobUrl","URL","createObjectURL","handleConvertByteArrayToPdf","byteArr","alert","data","toString","trim","replace","arrData","JSON","parse"],"mappings":"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","sourcesContent":["import b64toBlob from \"b64-to-blob\";\n\nexport const base64ArrayBuffer = (arrayBuffer) => {\n  var base64 = \"\";\n  var encodings =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  var bytes = new Uint8Array(arrayBuffer);\n  var byteLength = bytes.byteLength;\n  var byteRemainder = byteLength % 3;\n  var mainLength = byteLength - byteRemainder;\n\n  var a, b, c, d;\n  var chunk;\n\n  // Main loop deals with bytes in chunks of 3\n  for (var i = 0; i < mainLength; i = i + 3) {\n    // Combine the three bytes into a single integer\n    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n\n    // Use bitmasks to extract 6-bit segments from the triplet\n    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n    d = chunk & 63; // 63       = 2^6 - 1\n\n    // Convert the raw binary segments to the appropriate ASCII encoding\n    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n  }\n\n  // Deal with the remaining bytes and padding\n  if (byteRemainder === 1) {\n    chunk = bytes[mainLength];\n\n    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n\n    // Set the 4 least significant bits to zero\n    b = (chunk & 3) << 4; // 3   = 2^2 - 1\n\n    base64 += encodings[a] + encodings[b] + \"==\";\n  } else if (byteRemainder === 2) {\n    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\n\n    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n\n    // Set the 2 least significant bits to zero\n    c = (chunk & 15) << 2; // 15    = 2^4 - 1\n\n    base64 += encodings[a] + encodings[b] + encodings[c] + \"=\";\n  }\n\n  return base64;\n};\n\nconst openNewTab = (response) => {\n  var contentType = \"application/pdf\";\n  var sliceSize = 512;\n\n  var byteCharacters = atob(response);\n  var byteArrays = [];\n\n  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {\n    var slice = byteCharacters.slice(offset, offset + sliceSize);\n\n    var byteNumbers = new Array(slice.length);\n    for (var i = 0; i < slice.length; i++) {\n      byteNumbers[i] = slice.charCodeAt(i);\n    }\n\n    var byteArray = new Uint8Array(byteNumbers);\n\n    byteArrays.push(byteArray);\n  }\n\n  var blob = new Blob(byteArrays, { type: contentType });\n  blob = b64toBlob(response, contentType);\n  var blobUrl = URL.createObjectURL(blob);\n  return blobUrl;\n};\n\nexport const handleConvertByteArrayToPdf = (byteArr) => {\n  if (byteArr === \"\") {\n    alert(\"Input must not be empty !\");\n  } else {\n    \n    let data = byteArr.toString().trim().replace(/ /g, \"\");\n    data.replace(/\\r?\\n|\\r/g, \"\");\n    let arrData = JSON.parse(\"[\" + data + \"]\");\n    const base64 = base64ArrayBuffer(arrData);\n    return openNewTab(base64);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}